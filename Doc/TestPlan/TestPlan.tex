\documentclass[12pt, titlepage]{article}

\usepackage{booktabs}
\usepackage{tabularx}
\usepackage{hyperref}
\usepackage{longtable}
\usepackage{array}
\usepackage{graphicx}
\usepackage{float}
\usepackage{color}
\graphicspath{ {img/} }

\hypersetup{
    colorlinks,
    citecolor=black,
    filecolor=black,
    linkcolor=red,
    urlcolor=blue
}
\usepackage[round]{natbib}

\title{SE 3XA3: Test Plan\\ReTouch}

\author{Team \#7, ReTouchers
		\\ Abrar Attia - attiaa1
		\\ Susan Fayez - fayezs
		\\ Mediha Munim - munimm
}


\begin{document}

\maketitle

\pagenumbering{roman}
\tableofcontents
\listoftables
\listoffigures

\begin{table}[htp]
\caption{\bf Revision History}
\begin{tabularx}{\textwidth}{p{3cm}p{2cm}X}
\toprule {\bf Date} & {\bf Version} & {\bf Notes}\\
\midrule
October 27 & 1.0 & PoC, and Unit Tests added\\
October 27 & 1.1 & Added general information\\
October 27 & 1.2 & Added System Test Description\\
December 5 & 2.0 & Updated scope, testing approach, and testing tools\\
December 5 & 2.1 & Edited test cases for functional  requirements)\\
December 5 & 2.2 & Added links for symbolic parameters\\
December 6 & 2.3 & Edited test cases for non-functional requirements\\
December 6 & 2.4 & Updated naming conventions for non-functional tests to match srs doc\\
December 6 & 2.5 & Added test cases for FREQ16 and FREQ17\\
December 6 & 2.6 & Updated naming conventions for functional tests\\

\bottomrule
\end{tabularx}
\end{table}
\newpage

\pagenumbering{arabic}

This document describes the plan for testing ReTouch.

\section{General Information}

\subsection{Purpose}

	The purpose of this project is to re-implement the open source project K-Touch. K-Touch is a utility that allows users to track their speed and accuracy in typing, and results in improved typing skills through practice and repetition. The re-implementation will improve upon the original project by making it more user friendly and providing more comprehensive documentation. The purpose of this document is to make the testing for ReTouch as efficient as possible to ensure a robust, complete, and fully-functional program.

\subsection{Scope}

	The scope of ReTouch will be to improve KTouch by making it available on {\color{cyan} a wider variety of operating systems, while improving much of the functionality and user experience and still providing an intuitive GUI and a user guide.} Therefore, testing ReTouch will involve testing the GUI, the user input, file input and output, and the other algorithms. 

\subsection{Overview of Document}

	This document outlines several types of tests that the ReTouchers team plans to use, potential testing tools, a testing schedule, and specific test cases that will cover the functional and non-functional requirements of ReTouch. 

\section{Plan}
	
\subsection{Software Description}

\begin{figure}[h!]
	\includegraphics[scale=0.5]{KTouchLesson.png}
	\centering
	\caption{Visual Sample of K-Touch}
	\label{figure:1}
\end{figure}

	ReTouch will be implemented very similarly to K-Touch, the original application, in its functionality. The software shall begin by giving the user a list of lessons to choose from, where each lesson consists of a different combination of keyboard characters that the user can practice typing. The main program will begin at that point. A sequence of characters will appear on screen, and the user will be prompted to type those characters on the keyboard (as is seen in \hyperref[figure:1]{Figure 1}). The user must accurately type all of them (incorrectly typed characters can be erased and then typed again). The software will calculate the elapsed time, the user's typing accuracy, and the user's typing speed during the program's execution. Once the user has completed the lesson, the results of the lesson will appear on screen. The software will be implemented using Java.

\subsection{Test Team}

	The testing will be divided roughly equally among the ReTouchers team (Abrar Attia, Susan Fayez and Mediha Munim). Ideally, every member will be able to look over all of the components that need to be tested and contribute new cases to ensure robustness of the software, but this may not be possible due to the time constraints on the project. See the \hyperref[sec:ts]{Testing Schedule} for details.

\subsection{Testing Approach}

	Many different testing techniques will be utilized in the testing process. Black box testing will involve unit testing and integration testing. To automate these tests, the team will take advantage of JUnit's functionalities {\color{cyan} as well as AssertJ}. Private methods will be tested as well, and ideally testing will take place throughout the implementation process to ensure that the tests that passed early on in the process will still pass after finalizing the code. {\color{cyan} Regression testing will be used should we make any major changes to the implementation.} To test the internal framework of the software, white box testing will be used.{\color{cyan} The user input from the interface will be simulated using AssertJ's functionalities to make sure everything runs as expected.} Not all of the testing will be automatic - manual system testing will be vital to the final product because the project is expected to have a detailed GUI. Both static and dynamic test cases will be covered using tools described in \hyperref[sec:tt]{Testing Tools}. In system testing, the functionalities of KTouch can be compared to ReTouch to ensure that it works just as it was intended to by the original programmers. All in all, the ReTouchers team strives to test as efficiently and effectively as possible.

\subsection{Testing Tools}
\label{sec:tt}

	As mentioned earlier, {\color{cyan}the main tools for testing the Java code will be JUnit and AssertJ}. Static testing can take place automatically as the project will be implemented in Eclipse, which has static testing capabilities. JaCoCo is a code coverage tool that works well with Eclipse. However, due to the time constraints associated with the project and the potential learning curve with the library, it may not be used. Finally, Apache JMeter will be used for load testing.

\subsection{Testing Schedule}
\label{sec:ts}
		
The Gantt Project, which illustrates the project schedule, can be found \href{run:../../ProjectSchedule/Gantt_Project.gan}{here} or in the ProjectSchedule directory. 

\section{System Test Description}
	
\subsection{Tests for Functional Requirements}
The test numbers for the functional requirements test correspond to the related requirement.
\subsubsection{User Input}
		
\paragraph{Lesson Selection}

\begin{enumerate}

\item{{\color{cyan}FT1}\\}

Type: Functional, Dynamic, Manual.
					
Initial State: Lesson selection (start) screen.
					
Input: The desired Lesson.
					
Output: User redirected to beginning of Lesson screen.
					
How test will be performed: The function that runs the selected Lesson will be run. We will check that the correct Lesson was opened.

\item{{\color{cyan}FT16}\\}
{\color{cyan}
Type: Functional, Dynamic, Manual.
					
Initial State: The user is in the middle of a Lesson.
					
Input: The return to Lesson Selection button is pressed.
					
Output: The Lesson the user is working on is terminated and the Lesson Selection page is opened.
					
How test will be performed: The function that runs the selected Lesson will be run. A Lesson will be selected and then the return to Lesson Selection page button will be pressed. We will check that Lesson is closed and the Lesson Selection page is opened.
}

\item{{\color{cyan}FT17}\\}
{\color{cyan}
Type: Functional, Dynamic, Manual.
					
Initial State: The User has completed a Lesson and is on the Results page.
					
Input: The choose another Lesson button is pressed.
					
Output: The Results page is terminated and the Lesson Selection page is opened.
					
How test will be performed: The function that runs the selected Lesson will be run. A Lesson will be selected and the Lesson will be completed. The user will be redirected to the Results page and the select another Lesson button will be pressed. We will check that Results page is closed and the Lesson Selection page is opened.
}
\end{enumerate}
\paragraph{Lesson Execution}
\begin{enumerate}
    					
\item{{\color{cyan}FT4}\\}

Type: Functional, Dynamic, Manual.
					
Initial State: Beginning of the Lesson screen.
					
Input: A desired Lesson.
					
Output: The Lesson is run, the system sets the current character to the first character in the Lesson.
					
How test will be performed: The function that runs the selected Lesson will be run. We will check that the current character value is set to the first character in the given Lesson.

					
\item{{\color{cyan}FT5}\\}

Type: Functional, Dynamic, Manual.
					
Initial State: During a Lesson.
					
Input: User types any character.
					
Output: The system moves the current character value to the next one in the Lesson.
					
How test will be performed: The function that runs the Lesson will be run, user input will be provided. We will check the current character value for each time a character is entered to make sure it is being updated properly.

					
\item{{\color{cyan}FT6}\\}

Type: Functional, Dynamic, Manual.
					
Initial State: During a Lesson
					
Input: User types any character in the Lesson.
					
Output: The system sets that particular character in the Lesson as completed and the cursor moves on to the next character.
					
How test will be performed: The function that runs the Lesson will be run and user input will be entered. We will check that the system only marked the characters entered correctly as such and moves on to the next character when any character is entered.

\item{{\color{cyan}FT8(i)}\\}

{\color{cyan}Type: Functional, Dynamic, Manual.
					
Initial State: During the Lesson, when the user reaches the end of a line having completed the correct characters.
					
Input: The user hits the enter key.
					
Output: If the user can move on to the next line.
					
How test will be performed: The function that runs the Lesson will be run and the correct user input for the first line will be entered. When the enter button is pressed, we will check if the system gives the proper response, allowing the user to continue on to the next line.}

\item{{\color{cyan}FT8}(ii)}
{\color{cyan}
Type: Functional, Dynamic, Manual.
					
Initial State: During the Lesson, when the user reaches the end of a line, having made mistakes.
					
Input: The user hits the enter key.
					
Output: The user may not move on the the next line.
					
How test will be performed: The function that runs the Lesson will be run and user input for the first line will be entered with mistakes. When the enter button is pressed, we will check if the system gives the proper response, preventing the user from moving on to the next line.}

\item{{\color{cyan}FT14(i)}\\}
{\color{cyan}
Type: Functional, Dynamic, Manual.
					
Initial State: During the Lesson, when the user has finished typing everything correctly.
					
Input: The user hits the enter key.
					
Output: The Lesson page is closed
					
How test will be performed: The function that runs the Lesson will be run and the user input will be entered for the entire Lesson correctly. We will check to make sure the Lesson page terminates.}

\item{{\color{cyan}FT14(ii)}\\}
{\color{cyan}
Type: Functional, Dynamic, Manual.
					
Initial State: During the Lesson, when the user has finished typing everything but has made uncorrected mistakes.
					
Input: The user hits the enter key.
					
Output: The Lesson page does not terminate until the user goes back and corrects their mistakes.
					
How test will be performed: The function that runs the Lesson will be run and the user input will be entered for the entire Lesson with mistakes made on the last line. We will check to make sure the Lesson page does not terminate the Lesson page until after the mistakes are corrected and the user hits enter.}

\end{enumerate}

\paragraph{Lesson Mistakes and Corrections}

\begin{enumerate}

\item{{\color{cyan}FT7}\\}

Type: Functional, Dynamic, Manual.
					
Initial State: During the Lesson.
					
Input: The user enters an incorrect character.
					
Output: The system highlights the the character that was entered incorrectly, and if the user continues typing, each character after the initial incorrect character is highlighted as incorrect.
					
How test will be performed: The function that runs the Lesson will be run and the user input will be entered incorrectly. We will check that the appropriate characters will be highlighted as incorrect.

\item{{\color{cyan}FT9}\\}

Type: Functional, Dynamic, Manual.
					
Initial State: During the Lesson.
					
Input: The user enters the backspace key.
					
Output: The current character is moved to the previous character in the Lesson. If the current character is the first in the Lesson and backspace is entered, nothing happens.
					
How test will be performed: The function that runs the Lesson will be run and user input will be entered. The backspace key will be entered and we will check that the current character has moved appropriately.

\item{{\color{cyan}FT10}\\}
{\color{cyan}
Type: Functional, Dynamic, Automatic.
					
Initial State: During the Lesson.
					
Input: User input for the Lesson, with some mistakes.
					
Output: The number of characters entered incorrectly is stored in a variable.
					
How test will be performed: The function that runs the Lesson will be run and user input will be simulated, with several mistakes. We will check that the counter variable for the number of mistakes is equal to the actual number of mistakes.}
\end{enumerate}

\subsubsection{Display}
\paragraph{Lesson Generation}

\begin{enumerate}

\item{{\color{cyan}FT2}\\}

Type: Functional, Dynamic, Manual.
					
Initial State: Lesson selection screen
					
Input: The user selects a Lesson
					
Output: The system will generate a Lesson - a list of characters of less than \hyperref[symbols]{MAX\_LESSON} characters, including spaces.
					
How test will be performed: The function that runs the Lesson will be run and we will check that the Lesson generated is appropriate. 

\end{enumerate}

\paragraph{Lesson Display}

\begin{enumerate}


\item{{\color{cyan}FT3}\\}

Type: Structural
					
Initial State: The beginning of the Lesson.
					
Input: The user works on the Lesson.
					
Output: The system displays the list of characters in the Lesson. The list of characters will be presented on separate lines, with each line being no greater than constant \hyperref[symbols]{MAX\_LINE}.

					
How test will be performed: The function that runs the Lesson will be run and we will check that the Lesson is displayed.

\item{{\color{cyan}FT11}\\}

Type: Structural
					
Initial State: During the Lesson.
					
Input: The user works on the Lesson.
					
Output: The system displays the elapsed time, from when the user began the Lesson.
					
How test will be performed:  The function that runs the Lesson will be run and we will check that the timer is displayed.

\item{{\color{cyan}FT12}\\}
{\color{cyan}
Type: Functional, Dynamic, Automatic.
					
Initial State: During the Lesson.
					
Input: The user works on the Lesson.
					
Output: The system displays the user's typing accuracy.
					
How test will be performed:  The function that runs the Lesson will be run and user input will be simulated with mistakes. We will check that the value for the accuracy is what we expect it to be and displayed as such.}
\item{{\color{cyan}FT13}\\}

Type: Structural
					
Initial State: During the Lesson
					
Input: The user works on the Lesson
					
Output: The system displays the user's typing speed
					
How test will be performed:  The function that runs the Lesson will be run and we will check that the user's typing speed is displayed correctly.  

\item{{\color{cyan}FT15}\\}
{\color{cyan}
Type: Structural
					
Initial State: The Lesson is completed
					
Input: The user hits enter after they finish the Lesson
					
Output: The results (time, typing accuracy, and typing speed) are displayed to the user.
		
How test will be performed: The function that runs the Lesson will be run and the user input will be entered correctly. When the user has completed the Lesson, we will check that the Results page is opened with the correct results.}

\end{enumerate}

\subsection{Tests for Nonfunctional Requirements}

\subsubsection{Look and Feel}

\begin{enumerate}

\item{{\color{cyan}LF3}}

Type: Structural, Static, Manual
					
Initial State: Any screen of the application (Lesson Selection, Lesson, Results).
					
Input/Condition: The user navigates the application.
					
Output/Result: The GUI's components will be consistent in colour, text fonts, and window properties in order to keep the application organized and easy to navigate.
					
How test will be performed: We will navigate all three stages of the application to ensure that the aesthetic is consistent throughout.

\end{enumerate}

\subsubsection{Usability and Humanity}
\begin{enumerate}

\item{{\color{cyan}UH1}\\}

Type: Structural, Static, Manual
					
Initial State: The Lesson selected and about to begin.
					
Input/Condition: The user asked to complete the lesson, with no further guidance.
					
Output/Result: The user should be able to complete the lesson.
					
How test will be performed: A test group of users unfamiliar with the application will be asked to test it out.{\color{cyan} They will be asked to rate intuitiveness of the application and whether they could complete the lesson.}

\item{{\color{cyan}UH2}\\}

Type: Structural, Static, Manual
					
Initial State: The application unopened.
					
Input/Condition: The user, asked to complete the process of opening the application, selecting a Lesson, and viewing the results without further guidance.
					
Output/Result: The user should be able to easily navigate the three stages of the application.
					
How test will be performed:  A test group of users unfamiliar with the application will be asked to test it out.{\color{cyan} They will be asked to rate intuitiveness of the application and whether they were able to visit every page of the application.}

\item{{\color{cyan}UH3}\\}

Type: Structural, Static, Manual
					
Initial State: The application opened, the Lesson unselected.
					
Input/Condition: User asked to try various Lessons of varying difficulty.
					
Output/Result: The user should find at least one Lesson challenging/helpful in improving their typing skills.
					
How test will be performed:  A test group of users unfamiliar with the application and of varying levels of typing proficiency will be asked to test it out.{\color{cyan} They will be asked if they found any of the lessons challenging.}

\item{{\color{cyan}UH4}\\}

Type: Structural, Static, Manual
					
Initial State: The application not yet installed.
					
Input/Condition: The user asked to install the application.
					
Output/Result: The application should be easy for for the user to install.
					
How test will be performed:  A test group of users unfamiliar with the application will be asked to {\color{cyan} compile and run the program. They will be timed and rate the difficulty of this process.}

\end{enumerate}
\subsubsection{Performance}
\begin{enumerate}

\item{{\color{cyan}P1}\\}

Type: Structural, Dynamic, Manual
					
Initial State: During the Lesson.
					
Input/Condition: The user works on the Lesson.
					
Output/Result: The system will respond to the user input within 1 second.
					
How test will be performed: A user will work through a Lesson and we will check the response time as they go.{\color{cyan} We will also ask them if they experienced any lagging.} 

\item{{\color{cyan}P2}\\}

Type: Structural, Dynamic, Manual
					
Initial State: During the Lesson.
					
Input/Condition: The user works on the Lesson.
					
Output/Result: The timer displayed to the user will be accurate and begin once the {\color{cyan}lesson loads} and will end once the user hits enter {\color{cyan} on the last line} to complete the Lesson.
					
How test will be performed: A user will work on a Lesson and we will check that the timer is accurate.

\item{{\color{cyan}P5}\\}

Type: Structural, Static, Manual
					
Initial State: Any point in using the application.
					
Input/Condition: The user uses the application.
					
Output/Result: The application will not interfere with the user's machine.
					
How test will be performed: We will check on the user's machine during and after the application runs to ensure everything is running properly.

\end{enumerate}
\subsubsection{Operation and Environment}
\begin{enumerate}

\item{{\color{cyan} OE1}\\}

Type: Structural, Static, Manual
					
Initial State: Application compiled on a Windows, {\color{cyan}Mac}, and Linux machine.
					
Input/Condition: User runs the application on both machines.
					
Output/Result: The application should run smoothly on {\color{cyan} all} machines.
					
How test will be performed: Run the application on {\color{cyan}all} machines.

\item{{\color{cyan}OE2}}

Type: Structural, Static, Manual
					
Initial State: The application is unopened.
					
Input/Condition: The user opens the application.
					
Output/Result: The application depends on no other applications to run properly.
					
How test will be performed: We will open the application by itself, independent of any other applications.

\end{enumerate}

\subsubsection{Security}
\begin{enumerate}

\item{{\color{cyan}S1}\\}

Type: Structural, Static, Manual
					
Initial State: During a Lesson.
					
Input/Condition: The user completes the Lesson.
					
Output/Result: The system will not store any information on the user's results. 
					
How test will be performed: When the user completes their lesson, we will check to make sure none of the data is stored.

\end{enumerate}
\subsubsection{Cultural}
\begin{enumerate}

\item{{\color{cyan}C1}\\}

Type: Structural, Static, Manual
					
Initial State: The application is unopened.
					
Input/Condition: A user will be asked to open and go through the three stages of the application (Lesson Selection, Lesson, and Results).
					
Output/Result: The user shall not be offended by any of the content within the application.
					
How test will be performed: A test group of users unfamiliar with the application will be asked to use the application. {\color{cyan} We will ask them if they were offended by anything in the application.}
\end{enumerate}

\section{Tests for Proof of Concept}

The Proof of Concept testing will focus on validating that all the identified risks in the development of the application can be overcome. The determined risks that can be tested focus on running the code concurrently. The current program implements a constant timer alongside a main program that requests and waits for user keyboard input. 

\subsection{Running Programs Concurrently}
		
\paragraph{Constant Timer and User Input Verification}

\begin{enumerate}

\item{FC-1\\}

Type: Functional, Dynamic, Manual
					
Initial State: No input is set.
					
Input: User inputs characters.
					
Output: Calculated accuracy of user to match the expected characters.
					
How test will be performed: The user will be requested to input a certain character as the timer waits for their input. The final characters inputted will be compared to the initial requested characters to determine the user's accuracy. Therefore, half of the program that tests the users keyboard inputs will be tested. 
					
\item{FC-2\\}

Type: Functional, Dynamic, Manual
					
Initial State: No input is set.
					
Input: User inputs characters.
					
Output: The total time taken in comparison to the expected time and the user's speed calculation (the total characters per second).
					
How test will be performed: As the user inputs characters that are requested, the timer will be tracked. Once the lesson is run through, the total time the program records will be compared to the expected time. Also, the user's speed calculation will be compared to the expected characters per second to confirm that the timer is running efficiently. Therefore, such a test will confirm that the two programs are running concurrently and both sections are being completed successfully.

\end{enumerate}

	
\section{Comparison to Existing Implementation}	
There are currently no required tests to be done to compare the application to the existing implementation.
				
\section{Unit Testing Plan}

The JUnit unit testing framework {\color{cyan}as well as AssertJ} will be used to implement the unit testing for the ReTouch application.
		
\subsection{Unit testing of internal functions}

When testing the internal functions of the application, the unit tests will be based on each method's input parameters and their expected versus derived outputs. Each method will be testing with standard expected inputs as well as exceptions to improve the program's robustness and reduce bugs. Additionally, every class in the program will include all the required import statements. Therefore, the unit tests will not require any stubs or drivers when testing individual methods or components that depend on multiple methods. In addition, coverage metrics will be used to determine how much of the implemented code was tested. The goal to reach is 80\% code coverage. 
		
\subsection{Unit testing of output files}

When testing the output files and program outputs, there will need to be a comparison between the required output and the generated output. However, at this time, there are no expected output files that will be created when the program is run. 		

\newpage

\section{Appendix}

\subsection{Symbolic Parameters}
\label{symbols}

\begin{itemize}
\item MAX\_LESSON: The maximum number of characters per lesson.
\item MAX\_LINE: The maximum number of characters per line.
\end{itemize}

\end{document}